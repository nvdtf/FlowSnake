<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Matrix</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div>
        <label for="maps">Select a map:</label>
        <select id="maps">
            <!-- The options will be populated dynamically from JavaScript -->
        </select>
    </div>
    <div>
        <label for="numSnakes">Number of snakes:</label>
        <select id="numSnakes">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
        </select>
    </div>
    <div>
        <label for="moves">Moves:</label>
        <input type="text" id="moves" placeholder="Enter moves (L, R, U, D)">
    </div>
    <button id="goButton">Go!</button>
    <div></div>
    <canvas id="matrixCanvas" width="200" height="200"></canvas>
    <script>
        const cellSize = 40;
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        const goButton = document.getElementById('goButton');
        const numSnakesInput = document.getElementById('numSnakes');
        const movesInput = document.getElementById('moves');

        let fruits = [];
        let snakes = [];
        let snakeMovements = [];
        let movementInterval = null;
        let movementIndex = 0;

        // Define your maps
        const maps = [
            {
                name: 'SimpleBoardMap10',
                size: { x: 10, y: 10 },
                fruitSpawns: [
                    { x: 0, y: 0 },
                    { x: 2, y: 2 },
                    { x: 5, y: 5 },
                    { x: 3, y: 2 },
                    { x: 7, y: 1 },
                    { x: 7, y: 8 }
                ],
                playerSpawns: [
                    { x: 1, y: 1 },
                    { x: 8, y: 1 },
                    { x: 1, y: 8 },
                    { x: 8, y: 8 },
                ]
            },
            {
                name: 'SimpleBoardMap25',
                size: { x: 25, y: 25 },
                fruitSpawns: [
                    { x: 0, y: 0 },
                    { x: 2, y: 2 },
                    { x: 5, y: 5 },
                    { x: 3, y: 2 },
                    { x: 7, y: 1 },
                    { x: 7, y: 8 },
                    { x: 17, y: 11 },
                    { x: 21, y: 3 },
                    { x: 14, y: 6 },
                    { x: 3, y: 20 },
                    { x: 13, y: 22 },
                    { x: 23, y: 5 },
                    { x: 9, y: 8 },
                    { x: 11, y: 6 },
                    { x: 21, y: 21 }
                ],
                playerSpawns: [
                    { x: 1, y: 1 },
                    { x: 23, y: 1 },
                    { x: 1, y: 23 },
                    { x: 23, y: 23 },
                ]
            }
        ];

        // Get the select element
        const mapSelect = document.getElementById('maps');

        // Populate the select element with the map names
        maps.forEach((map, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = map.name;
            mapSelect.appendChild(option);
        });


        const directions = {
            'U': {x: 0, y: -1},
            'D': {x: 0, y: 1},
            'L': {x: -1, y: 0},
            'R': {x: 1, y: 0}
        };

        function drawMatrix() {
            for (let i = 0; i < 25; i++) {
                for (let j = 0; j < 25; j++) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }

        drawMatrix();

        function drawSnake(snake, color) {
            ctx.fillStyle = color;
            for (const cell of snake) {
                ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
            }
        }

        function drawFruit(coord) {
            ctx.fillStyle = 'red';
            ctx.font = `30px Arial`;
            ctx.fillText('🍎', coord.x * cellSize + 5, (coord.y + 1) * cellSize - 10);
        }


        function checkFruitCollision(snake) {
            const head = snake[0];
            for (let i = 0; i < fruits.length; i++) {
                if (fruits[i].x === head.x && fruits[i].y === head.y) {
                    // Remove the fruit
                    fruits.splice(i, 1);

                    // Return true to indicate a fruit collision
                    return true;
                }
            }

            // Return false if there was no fruit collision
            return false;
        }

        function moveSnake(snake, direction) {
            // Create new head based on the direction
            const newHead = {
                x: (snake[0].x + direction.x + boardSize.x) % boardSize.x,
                y: (snake[0].y + direction.y + boardSize.y) % boardSize.y,
            };

            // Add the new head to the snake body
            snake.unshift(newHead);

            // Check for fruit collision before removing tail
            if (!checkFruitCollision(snake)) {
                // If there was no fruit collision, remove the tail
                snake.pop();
            }

            return snake;
        }

        function render() {
            drawMatrix();
            const colors = ['green', 'blue', 'red', 'yellow'];
            snakes.forEach((snake, index) => {
                drawSnake(snake, colors[index]);
            });
            fruits.forEach(fruit => {
                drawFruit(fruit);
            });
        }

        function moveSnakes() {
            if (movementIndex < snakeMovements.length) {
                const move = snakeMovements[movementIndex];
                snakes[move.snake] = moveSnake(snakes[move.snake], move.movement);
                checkFruitCollision(snakes[move.snake]);
                render();
                movementIndex++;
            } else {
                clearInterval(movementInterval);
            }
        }

        function startAnimation() {
             // Get the selected map
            const map = maps[parseInt(mapSelect.value)];

            // Use the map size
            boardSize = map.size;

            // Use the map fruit spawns
            fruits = [...map.fruitSpawns];

            // Use the map player spawns to create the snakes
            const numSnakes = parseInt(numSnakesInput.value);
            snakes = [];
            for (let i = 0; i < numSnakes; i++) {
                snakes.push([
                    Object.assign({}, map.playerSpawns[i]), // Head
                ]);
            }

            const moves = movesInput.value.split('');

            // Create the movements
            snakeMovements = [];
            for (let i = 0; i < moves.length; i++) {
                const movement = {snake: i % numSnakes, movement: directions[moves[i]]};
                snakeMovements.push(movement);
            }

            canvas.width = boardSize.x * cellSize;
            canvas.height = boardSize.y * cellSize;

            movementIndex = 0;
            render();
            movementInterval = setInterval(moveSnakes, 100);
        }


        goButton.addEventListener('click', startAnimation);
    </script>
</body>
</html>


    </script>
</body>
</html>
